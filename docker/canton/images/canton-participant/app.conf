include file("storage.conf")

canton {
  features {
    enable-preview-commands = yes
    enable-testing-commands = yes
  }
  parameters {
    manual-start = no
    non-standard-config = yes
    # Bumping because our topology state can get very large due to
    # a large number of participants.
    timeouts.processing.verify-active = 40.seconds
    timeouts.processing.slow-future-warn = 20.seconds
  }

  # Bumping because our topology state can get very large due to
  # a large number of participants.
  monitoring.logging.delay-logging-threshold = 40.seconds

  participants {
    participant {
      init = {
          generate-topology-transactions-and-keys = false
          identity.type = manual
      }

      sequencer-client {
        acknowledgement-interval = 10m
        # Use a higher number of in flight batches to increase throughput
        maximum-in-flight-event-batches = 50
        use-new-connection-pool = true
        enable-amplification-improvements = true
      }

      monitoring.grpc-health-server {
        address = "0.0.0.0"
        port = 5061
      }
      storage = ${_storage}
      storage {
        config {
           properties = {
             serverName = ${?CANTON_PARTICIPANT_POSTGRES_SERVER}
             portNumber = ${?CANTON_PARTICIPANT_POSTGRES_PORT}
             databaseName = "participant"
             databaseName = ${?CANTON_PARTICIPANT_POSTGRES_DB}
             currentSchema = "participant"
             currentSchema = ${?CANTON_PARTICIPANT_POSTGRES_SCHEMA}
             user = ${?CANTON_PARTICIPANT_POSTGRES_USER}
             password = ${?CANTON_PARTICIPANT_POSTGRES_PASSWORD}
           }
         }
         parameters {
           max-connections = 32
         }
       }

      admin-api {
        address = "0.0.0.0"
        port = 5002
        limits.active {
          "com.digitalasset.canton.admin.participant.v30.ParticipantRepairService/ExportAcsOld": 1,
          "com.digitalasset.canton.admin.participant.v30.ParticipantRepairService/ExportAcs": 5,
          "com.digitalasset.canton.admin.participant.v30.ParticipantRepairService/ImportAcsOld": 1,
          "com.digitalasset.canton.admin.participant.v30.ParticipantRepairService/ImportAcs": 5,
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/ExportTopologySnapshot": 1,
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/ExportTopologySnapshotV2": 1
        }
      }

      init {
        ledger-api.max-deduplication-duration = 30s
      }

      ledger-api {
        # TODO(i29736) Revisit this; we want to avoid users to have to set an exp field in their tokens
        max-token-lifetime = Inf
        # Required for pruning
        admin-token-config.admin-claim=true
        address = "0.0.0.0"
        port = 5001
        user-management-service.additional-admin-user-id = ${?CANTON_PARTICIPANT_ADMIN_USER_NAME}
        auth-services = [{
          type = jwt-jwks
          url = ${AUTH_JWKS_URL}

          # Should use different audiences per participant: DACH-NY/canton-network-internal#502
          target-audience = ${AUTH_TARGET_AUDIENCE}
        }]
        # We need to bump this because we run one stream per user +
        # polling for domain connections which can add up quite a bit
        # once you're around ~100 users.
        rate-limit.max-api-services-queue-size = 80000
        interactive-submission-service {
          enable-verbose-hashing = true
        }
        topology-aware-package-selection {
            enabled = true
            enabled = ${?CANTON_PARTICIPANT_ENABLE_TOPOLOGY_PACKAGE_SELECTION}
        }
      }

      http-ledger-api {
        port = 7575
        address = 0.0.0.0
        path-prefix = ${?CANTON_PARTICIPANT_JSON_API_SERVER_PATH_PREFIX}
      }

      parameters {
        initial-protocol-version = 34
        # tune the synchronisation protocols contract store cache
        caching {
          contract-store {
            maximum-size = 1000 # default 1e6
            expire-after-access = 120s # default 10 minutes
          }
        }
        # Bump ACS pruning interval to make sure ACS snapshots are available for longer
        journal-garbage-collection-delay = 24h
        # TODO(i21502) Remove once ACS commitment processing does not block at all anymore.
        do-not-await-on-checking-incoming-commitments = true
        # trigger catchup if the acs commitment processor has more than configuration acs changes to process
        # this can be useful after longer periods of downtime to avoid hogging resources for acs commitment processing
        commitment-processor-nr-acs-changes-behind-to-trigger-catch-up = 10000
        # Bump batch size to make acs imports faster
        batching.max-acs-import-batch-size = 10000
      }

      ledger-api {
        index-service {
          max-contract-state-cache-size = 1000 # default 1e4
          max-contract-key-state-cache-size = 1000 # default 1e4

          # The in-memory fan-out will serve the transaction streams from memory as they are finalized, rather than
          # using the database. Therefore, you should choose this buffer to be large enough such that the likeliness of
          # applications having to stream transactions from the database is low. Generally, having a 10s buffer is
          # sensible. Therefore, if you expect e.g. a throughput of 20 tx/s, then setting this number to 200 is sensible.
          # The default setting assumes 100 tx/s.
          max-transactions-in-memory-fan-out-buffer-size = 200 # default 1000
        }
        # Restrict the command submission rate (mainly for SV participants, since they are granted unlimited traffic)
        command-service {
          max-commands-in-flight = 30 # default = 256
        }
      }

      topology {
        broadcast-batch-size = 1
        validate-initial-topology-snapshot = false
      }
    }
  }
}
