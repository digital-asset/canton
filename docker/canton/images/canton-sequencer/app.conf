include file("storage.conf")

canton {
  # required for key export
  features {
    enable-preview-commands = yes
  }
  parameters {
    manual-start = no
    non-standard-config = yes
    timeouts.processing.slow-future-warn = 20.seconds
  }

  sequencers {
    sequencer {
      init = {
          generate-topology-transactions-and-keys = false
          identity.type = manual
      }
      sequencer-client {
        acknowledgement-interval = 10m
      }
      storage = ${_storage}
      storage.config.properties {
          serverName = ${?CANTON_DOMAIN_POSTGRES_SERVER}
          portNumber = ${?CANTON_DOMAIN_POSTGRES_PORT}
          currentSchema = "sequencer"
          databaseName = "sequencer"
          databaseName = ${?CANTON_SEQUENCER_POSTGRES_DB}
          user = ${?CANTON_DOMAIN_POSTGRES_USER}
          password = ${?CANTON_DOMAIN_POSTGRES_PASSWORD}
      }

      monitoring.grpc-health-server {
        address = "0.0.0.0"
        port = 5061
      }

      public-api {
        address = "0.0.0.0"
        port = 5008
        max-token-expiration-interval = ${?SEQUENCER_TOKEN_EXPIRATION_TIME}
        # randomize to avoid issues with correlated failures
        use-exponential-random-token-expiration = true
      }

      admin-api {
        address = "0.0.0.0"
        port = 5009
        max-inbound-message-size = 104857600 # 100MB
        limits.active {
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/GenesisState": 1,
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/GenesisStateV2": 1,
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/ExportTopologySnapshot": 1,
          "com.digitalasset.canton.topology.admin.v30.TopologyManagerReadService/ExportTopologySnapshotV2": 1,
          "com.digitalasset.canton.sequencer.admin.v30.SequencerAdministrationService/OnboardingState": 1,
          "com.digitalasset.canton.sequencer.admin.v30.SequencerAdministrationService/OnboardingStateV2": 1
        }
      }


      # Reduced time proof request interval here (default 24h)
      # so that sequencer will not block other sequencers from pruning even there is lack of activities
      # ref: https://github.com/DACH-NY/canton/issues/16371#issuecomment-1885005687
      # Note that this needs to be shorter than the SEQUENCER_RETENTION_PERIOD
      # or our own sequencer will prevent pruning.
      # Time requests are much less expensive than Daml transactions
      # so given our target load this is neglible.
      time-tracker.min-observation-duration = 30m

      parameters {
        batching.max-pruning-time-interval = "10 minutes"
      }
      sequencer {
        block {
          writer {
            type = high-throughput
            # maximum memory the buffered events will occupy
            buffered-events-max-memory = 200MiB // higher buffers for clients that have lagging subscriptions
            buffered-events-preload-batch-size = 1000 // increase the number of events we load in each query during startup to reduce startup time
            # increase payload queue size to have the same behavior as the cometbft sequencer
            payload-queue-size = 2500
          }
          throughput-cap  {
            enabled = true
            messages = {
              confirmation-request = {
                # Global TPS cap for this message type is 20. Over 60 seconds, this means the global usage is 1200.
                # If over the past 60seconds, at least 90% of these 1200 messages are observed, every client gets 1200 / (1 + vActive), where vActive is the number of clients that have sent at least one #thing in the past 60seconds.
                # If the usage was below 90%, then the client would be able to reach their allotted 5tps.
                global-tps-cap = 20
                per-client-tps-cap = 5
                global-kbps-cap = 1000
                per-client-kbps-cap = 400
              }
              topology = {
                # TODO(i29485): really high values that more or less mean the topology caps are disabled because time advancing messages are topology transactions as well and they are not retried
                # and if we throttle time advancing messages then we would actually get more time proofs which cannot be throttled currently
                global-tps-cap = 200
                per-client-tps-cap = 10
                global-kbps-cap = 2000
                per-client-kbps-cap = 500
              }
            }
          }
        }
        config {
          storage = ${_storage}
          storage.config.properties {
              serverName = ${?CANTON_DOMAIN_POSTGRES_SERVER}
              serverName = ${?SEQUENCER_DRIVER_DATABASE_ADDRESS}
              portNumber = ${?CANTON_DOMAIN_POSTGRES_PORT}
              currentSchema = "sequencer_driver"
              databaseName = "sequencer_driver"
              databaseName = ${?CANTON_SEQUENCER_POSTGRES_DB}
              user = ${?CANTON_DOMAIN_POSTGRES_USER}
              password = ${?SEQUENCER_DRIVER_DATABASE_PASSWORD}
          }
        }
        type = reference
      }

      sequencer-client {
        use-new-connection-pool = true
      }

      public-api.limits.active = {
        "com.digitalasset.canton.sequencer.api.v30.SequencerService/DownloadTopologyStateForInit" : 3,
        "com.digitalasset.canton.sequencer.api.v30.SequencerService/Subscribe" : 1000,
      }
    }
  }
}
