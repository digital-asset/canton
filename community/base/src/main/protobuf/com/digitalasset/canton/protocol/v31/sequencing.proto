// Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.canton.protocol.v31;

import "com/digitalasset/canton/crypto/v30/crypto.proto";
import "com/digitalasset/canton/protocol/v30/common_stable.proto";
import "com/digitalasset/canton/protocol/v30/sequencing.proto";
import "com/digitalasset/canton/protocol/v30/traffic_control_parameters.proto";
import "google/rpc/status.proto";
import "scalapb/scalapb.proto";

message EnvelopeWithoutRecipients {
  // Contains a v30.EnvelopeContent if signatures are empty and a v30.TypedSignedProtocolMessageContent otherwise
  bytes content = 1;

  // An honest sequencer rejects the request if it contains an envelope with an invalid signature.
  // As only honest sequencers verify signatures, clients should not trust a single sequencer node to verify signatures for them.
  repeated com.digitalasset.canton.crypto.v30.Signature signatures = 2;
}

message CompressedBatch {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  v30.CompressedBatch.CompressionAlgorithm algorithm = 1;

  // A wrapper for a collection of recipients
  message DecompressedRecipients {
    repeated v30.Recipients recipients = 1;
  }

  // DecompressedRecipients
  bytes compressed_recipients = 2;

  // contains possibly compressed v31.EnvelopeWithoutRecipients
  repeated bytes compressed_envelopes = 3;
}

message SequencedEvent {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.AlphaProtoVersion";

  // The timestamp of the previous event of the member's event sequence.
  // in microseconds of UTC time since Unix epoch
  // Optional, set to None if this is the first ever event of the member's event sequence.
  optional int64 previous_timestamp = 1;

  // The timestamp of the event. Unique and monotonically increasing.
  // The same event has the same timestamp for all recipients.
  // in microseconds of UTC time since Unix epoch
  int64 timestamp = 2;

  // The synchronizer on which the event has been sequenced.
  string physical_synchronizer_id = 3;

  // The message_id of the request.
  // Optional, but will be defined iff the request sender is the subscriber.
  optional string message_id = 4;

  // The payload of the event.
  // Optional, defined iff deliver_error_reason is undefined.
  CompressedBatch batch = 5;

  // Optional error, indicates why the underlying SubmissionRequest has been rejected.
  google.rpc.Status deliver_error_reason = 6;

  // Optional timestamp of the topology snapshot used for processing the underlying request
  // (e.g., validation, signing, resolving group addresses).
  // If undefined, timestamp is used instead.
  optional int64 topology_timestamp = 7;

  // Traffic receipt with information about the traffic state after the cost for this event has been consumed
  // Optional - only set on deliver receipt sent back to the sender of the event when traffic control is enabled
  com.digitalasset.canton.protocol.v30.TrafficReceipt traffic_receipt = 8;
}

message SubmissionRequest {
  option (scalapb.message).companion_extends = "com.digitalasset.canton.version.StableProtoVersion";

  // Sender of the request.
  // This request must be wrapped in a SignedContent and
  // the signature therein must validate under one of the sender's public keys.
  // The request metadata must contain a valid authentication token belonging to the sender.
  // (Details in SequencerAuthenticationServerInterceptor.)
  // TARGET STATE: The sender must be authorized (cf. TopologySnapshot.isMemberKnown)
  // CURRENT STATE: The sender authorization check might have a few gaps (e.g., see MemberAuthenticationService.isActive)
  //   and/or may use the wrong snapshot.
  string sender = 1;

  // Will be included in the receipt of the request.
  // The sender should not reuse a message_id until max_sequencing_time,
  // because otherwise it will be unable to correlate receipts with requests.
  string message_id = 2;

  // The payload, mandatory
  // At most one recipient of an envelope may be (a) a mediator, (b) a mediator group, or (c) all synchronizer members.
  CompressedBatch batch = 4;

  // Maximum sequencing time for the request.
  // If the request can't be sequenced until the specified time, the sequencer will reject it.
  // After max_sequencing_time, no event corresponding to the request will be emitted.
  // in microseconds of UTC time since Unix epoch
  int64 max_sequencing_time = 5;

  // Optional timestamp (in microseconds of UTC time since Unix epoch) of topology snapshot to be used for
  // processing the request (e.g., validation, signing, resolving group addresses).
  // If defined, it must meet the following conditions:
  // (1) it must be before or at the sequencing timestamp,
  // (2) it must be by at most DynamicSynchronizerParameters.sequencerTopologyTimestampTolerance before the sequencing timestamp,
  //     where the DynamicSynchronizerParameters are taken from the topology state at topology_timestamp,
  // (3) the sequencer must have signing keys registered in the topology snapshot.
  // If defined and invalid, the request is rejected.
  // If undefined or invalid, the topology snapshot at sequencing time will be used instead.
  optional int64 topology_timestamp = 6;

  // Optional rule used to aggregate requests.
  v30.AggregationRule aggregation_rule = 7;

  // Optional submission cost computed by the sender. Must be provided if traffic control is enabled on the receiving synchronizer.
  v30.SequencingSubmissionCost submission_cost = 8;
}
