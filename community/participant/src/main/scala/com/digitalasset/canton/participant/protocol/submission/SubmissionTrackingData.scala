// Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.participant.protocol.submission

import cats.syntax.option._
import com.daml.ledger.participant.state.v2.CompletionInfo
import com.daml.ledger.participant.state.v2.Update.CommandRejected
import com.daml.ledger.participant.state.v2.Update.CommandRejected.RejectionReasonTemplate
import com.digitalasset.canton.ProtoDeserializationError.FieldNotSet
import com.digitalasset.canton.data.CantonTimestamp
import com.digitalasset.canton.error.TransactionError
import com.digitalasset.canton.logging.ErrorLoggingContext
import com.digitalasset.canton.logging.pretty.{Pretty, PrettyPrinting}
import com.digitalasset.canton.participant.LedgerSyncEvent
import com.digitalasset.canton.participant.protocol.version.VersionedSubmissionTrackingData
import com.digitalasset.canton.participant.protocol.{TransactionProcessor, v0}
import com.digitalasset.canton.participant.store.{
  SerializableCompletionInfo,
  SerializableRejectionReasonTemplate,
}
import com.digitalasset.canton.sequencing.protocol.DeliverErrorReason
import com.digitalasset.canton.serialization.ProtoConverter
import com.digitalasset.canton.serialization.ProtoConverter.ParsingResult
import com.digitalasset.canton.util.{HasProtoV0, HasVersionedWrapper, HasVersionedWrapperCompanion}
import com.digitalasset.canton.version.ProtocolVersion
import com.google.protobuf.empty.Empty

/** The data of an in-flight unsequenced submission that suffices to produce a rejection reason.
  * This data is persisted in the [[com.digitalasset.canton.participant.store.InFlightSubmissionStore]]
  * for unsequenced submissions and updated when the corresponding
  * a [[com.digitalasset.canton.sequencing.protocol.DeliverError]] is processed
  * or the submission could not be sent to the sequencer.
  */
trait SubmissionTrackingData
    extends Product
    with Serializable
    with HasProtoV0[v0.SubmissionTrackingData]
    with HasVersionedWrapper[VersionedSubmissionTrackingData]
    with PrettyPrinting {

  /** Produce a rejection event for the unsequenced submission using the given record time. */
  def rejectionEvent(recordTime: CantonTimestamp)(implicit
      loggingContext: ErrorLoggingContext
  ): LedgerSyncEvent

  /** Update the tracking data so that the [[com.digitalasset.canton.sequencing.protocol.DeliverErrorReason]]
    * can be taken into account by [[rejectionEvent]].
    *
    * @param timestamp The sequencer timestamp of the [[com.digitalasset.canton.sequencing.protocol.DeliverError]].
    * @param reason The reason for the deliver error generated by the sequencer.
    */
  def updateOnNotSequenced(timestamp: CantonTimestamp, reason: DeliverErrorReason)(implicit
      loggingContext: ErrorLoggingContext
  ): Option[UnsequencedSubmission]
}

object SubmissionTrackingData
    extends HasVersionedWrapperCompanion[VersionedSubmissionTrackingData, SubmissionTrackingData] {
  override protected def ProtoClassCompanion: VersionedSubmissionTrackingData.type =
    VersionedSubmissionTrackingData
  override protected def name: String = "submission tracking data"

  override def fromProtoVersioned(
      versionedSubmissionTracking: VersionedSubmissionTrackingData
  ): ParsingResult[SubmissionTrackingData] = {
    versionedSubmissionTracking match {
      case VersionedSubmissionTrackingData(
            VersionedSubmissionTrackingData.Version.V0(submissionTrackingV0)
          ) =>
        fromProtoV0(submissionTrackingV0)
      case VersionedSubmissionTrackingData(VersionedSubmissionTrackingData.Version.Empty) =>
        Left(FieldNotSet("version"))
    }
  }

  def fromProtoV0(
      submissionTrackingP: v0.SubmissionTrackingData
  ): ParsingResult[SubmissionTrackingData] = {
    val v0.SubmissionTrackingData(tracking) = submissionTrackingP
    tracking match {
      case v0.SubmissionTrackingData.Tracking.Transaction(transactionSubmissionTracking) =>
        TransactionSubmissionTrackingData.fromProtoV0(transactionSubmissionTracking)
      case v0.SubmissionTrackingData.Tracking.Empty => Left(FieldNotSet("tracking"))
    }
  }
}

/** Tracking data for transactions */
case class TransactionSubmissionTrackingData(
    completionInfo: CompletionInfo,
    rejectionCause: TransactionSubmissionTrackingData.RejectionCause,
) extends SubmissionTrackingData {

  override def rejectionEvent(
      recordTime: CantonTimestamp
  )(implicit loggingContext: ErrorLoggingContext): LedgerSyncEvent = {

    val reasonTemplate = rejectionCause.asRejectionReasonTemplate(recordTime)
    CommandRejected(recordTime.toLf, completionInfo, reasonTemplate)

  }

  override def updateOnNotSequenced(timestamp: CantonTimestamp, reason: DeliverErrorReason)(implicit
      loggingContext: ErrorLoggingContext
  ): Option[UnsequencedSubmission] = {
    val deliverError = TransactionProcessor.SubmissionErrors.SequencerDeliver.Error(reason)
    UnsequencedSubmission(
      timestamp,
      this.copy(rejectionCause = TransactionSubmissionTrackingData.CauseWithTemplate(deliverError)),
    ).some
  }

  override protected def toProtoVersioned(
      version: ProtocolVersion
  ): VersionedSubmissionTrackingData =
    VersionedSubmissionTrackingData(version = VersionedSubmissionTrackingData.Version.V0(toProtoV0))

  override protected def toProtoV0: v0.SubmissionTrackingData = {
    val completionInfoP = SerializableCompletionInfo(completionInfo).toProtoV0
    val transactionTracking = v0.TransactionSubmissionTrackingData(
      completionInfo = completionInfoP.some,
      rejectionCause = rejectionCause.toProtoV0.some,
    )
    v0.SubmissionTrackingData(v0.SubmissionTrackingData.Tracking.Transaction(transactionTracking))
  }

  override def pretty: Pretty[TransactionSubmissionTrackingData] = prettyOfClass(
    param("completion info", _.completionInfo),
    param("rejection cause", _.rejectionCause),
  )
}

object TransactionSubmissionTrackingData {
  def fromProtoV0(
      tracking: v0.TransactionSubmissionTrackingData
  ): ParsingResult[TransactionSubmissionTrackingData] = {
    val v0.TransactionSubmissionTrackingData(completionInfoP, causeP) = tracking
    for {
      completionInfo <- ProtoConverter.parseRequired(
        SerializableCompletionInfo.fromProtoV0,
        "completion info",
        completionInfoP,
      )
      cause <- ProtoConverter.parseRequired(RejectionCause.fromProtoV0, "rejection cause", causeP)
    } yield TransactionSubmissionTrackingData(completionInfo, cause)
  }

  trait RejectionCause
      extends Product
      with Serializable
      with PrettyPrinting
      with HasProtoV0[v0.TransactionSubmissionTrackingData.RejectionCause] {

    def asRejectionReasonTemplate(observedTimestamp: CantonTimestamp)(implicit
        loggingContext: ErrorLoggingContext
    ): RejectionReasonTemplate

    override def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause
  }

  object RejectionCause {
    def fromProtoV0(
        proto: v0.TransactionSubmissionTrackingData.RejectionCause
    ): ParsingResult[RejectionCause] = {
      val v0.TransactionSubmissionTrackingData.RejectionCause(cause) = proto
      cause match {
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Timeout(empty) =>
          TimeoutCause.fromProtoV0(empty)
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause
              .RejectionReasonTemplate(template) =>
          CauseWithTemplate.fromProtoV0(template)
        case v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Empty =>
          Left(FieldNotSet("TransactionSubmissionTrackingData.RejectionCause.cause"))
      }
    }
  }

  case object TimeoutCause extends RejectionCause {

    override def asRejectionReasonTemplate(
        observedTimestamp: CantonTimestamp
    )(implicit loggingContext: ErrorLoggingContext): RejectionReasonTemplate = {
      val error = TransactionProcessor.SubmissionErrors.TimeoutError.Error(observedTimestamp)
      error.logWithContext()
      error.createRejection
    }

    override def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause =
      v0.TransactionSubmissionTrackingData.RejectionCause(
        cause = v0.TransactionSubmissionTrackingData.RejectionCause.Cause.Timeout(Empty())
      )

    override def pretty: Pretty[TimeoutCause.type] = prettyOfObject[TimeoutCause.type]

    def fromProtoV0(_empty: Empty): ParsingResult[TimeoutCause.type] = Right(
      this
    )
  }

  final case class CauseWithTemplate(template: RejectionReasonTemplate) extends RejectionCause {
    override def asRejectionReasonTemplate(_observedTimestamp: CantonTimestamp)(implicit
        loggingContext: ErrorLoggingContext
    ): RejectionReasonTemplate = template

    override def toProtoV0: v0.TransactionSubmissionTrackingData.RejectionCause =
      v0.TransactionSubmissionTrackingData.RejectionCause(
        cause = v0.TransactionSubmissionTrackingData.RejectionCause.Cause.RejectionReasonTemplate(
          SerializableRejectionReasonTemplate(template).toProtoV0
        )
      )

    override def pretty: Pretty[CauseWithTemplate] = prettyOfClass(
      unnamedParam(_.template)
    )
  }

  object CauseWithTemplate {

    /** Log the `error`` and then convert it into a
      * [[com.daml.ledger.participant.state.v2.Update.CommandRejected.RejectionReasonTemplate]]
      */
    def apply(
        error: TransactionError
    )(implicit loggingContext: ErrorLoggingContext): CauseWithTemplate = {
      error.logWithContext()
      CauseWithTemplate(error.createRejection)
    }

    def fromProtoV0(
        templateP: v0.CommandRejected.GrpcRejectionReasonTemplate
    ): ParsingResult[CauseWithTemplate] =
      for {
        template <- SerializableRejectionReasonTemplate.fromProtoV0(templateP)
      } yield CauseWithTemplate(template)
  }
}
