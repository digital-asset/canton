// Copyright (c) 2023 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

syntax = "proto3";

package com.digitalasset.canton.participant.protocol.v0.multidomain;

import "com/daml/ledger/api/v1/event.proto";
import "com/daml/ledger/api/v1/transaction_filter.proto";
import "com/digitalasset/canton/participant/protocol/v0/multidomain/transfer.proto";
import "com/digitalasset/canton/protocol/v0/topology.proto";

option csharp_namespace = "Com.Digitalasset.Canton.Participant.Protocol.V0.Multidomain";
option java_outer_classname = "UpdateServiceOuterClass";
option java_package = "com.digitalasset.canton.participant.protocol.v0.multidomain";

// Allows clients to get state from the ledger.
service StateService {
  // Returns a stream of the snapshot of the active contracts at a ledger offset.
  // If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken.
  // Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service.
  // Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.
  rpc GetActiveContracts(GetActiveContractsRequest) returns (stream GetActiveContractsResponse);

  // Get the list of connected domains to which the party has the rights to submit to and the
  // participant is connected to.
  rpc GetConnectedDomains(GetConnectedDomainsRequest) returns (GetConnectedDomainsResponse);

  // Get the current ledger end.
  // Subscriptions started with the returned offset will serve updates created after this RPC was called.
  rpc GetLedgerEnd(GetLedgerEndRequest) returns (GetLedgerEndResponse);
}

message GetActiveContractsRequest {
  // The offset at which the snapshot of the in-flight transfers will be computed.
  // Must be no greater than the current ledger end offset.
  // Must be greater than or equal to the last pruning offset.
  // If not set the current ledger end offset will be used.
  // Optional
  string valid_at_offset = 1;

  // Templates to include in the served snapshot, per party.
  // Note: interface filter is not supported
  // Required
  com.daml.ledger.api.v1.TransactionFilter filter = 2;
}

message ContractStateComponent {
  oneof contract_state_component {
    // The contract is active in the given domain.
    // There will be one such message for each domain the contract is active in.
    //
    // Note: currently contains at most one such message per contract, indicating on which domain the
    // contract can be used (at the given offset).
    ActiveContract active_contract = 1;

    // This message is only available, if the corresponding transfer-in event cannot be found before or at the
    // active_at_offset, and at least one of the querying parties could submit the corresponding transfer-in command.
    // The incomplete_transferred_out.created_event.witness_parties will contain all such querying parties.
    IncompleteTransferredOut incomplete_transferred_out = 2;

    // Important: this message is not indicating that the contract is active for the target domain!
    // This message is only available, if the corresponding transfer-out event cannot be found before or at the
    // active_at_offset, and at least one of the querying parties could have submitted the corresponding transfer-in command.
    // The incomplete_transferred_in.transferred_in_event.created_event.witness_parties will contain all such querying parties.
    IncompleteTransferredIn incomplete_transferred_in = 3;
  }
}

message GetActiveContractsResponse {
  // Included only in the last message.
  // The client should start consuming the transactions endpoint with this offset.
  // The format of this field is described in ``ledger_offset.proto``.
  string offset = 1;

  // For each contract there could be multiple ContractStateComponent-s in the entire snapshot. These together define
  // the state of the contract in the snapshot.
  repeated ContractStateComponent contract_state_components = 2;
}

message ActiveContract {
  // Required
  com.daml.ledger.api.v1.CreatedEvent created_event = 1;

  // A valid domain ID
  // Required
  string domain_id = 2;
}

message IncompleteTransferredOut {
  // Required
  com.daml.ledger.api.v1.CreatedEvent created_event = 1;

  // Required
  TransferredOutEvent transferred_out_event = 2;
}

message IncompleteTransferredIn {
  TransferredInEvent transferred_in_event = 1;
}

message GetConnectedDomainsRequest {
  // The submitting party
  // Must be a valid PartyIdString (as described in ``value.proto``).
  // Required
  string party = 1;
}

message GetConnectedDomainsResponse {
  message ConnectedDomain {
    // The alias of the domain
    string domain_alias = 1;
    // The ID of the domain
    string domain_id = 2;
    // The permission on the domain
    com.digitalasset.canton.protocol.v0.ParticipantPermission permission = 3;
  }
  repeated ConnectedDomain connected_domains = 1;
}

message GetLedgerEndRequest {
  // Must correspond to the ledger ID reported by the Ledger Identification Service.
  // Must be a valid LedgerString (as describe in ``value.proto``).
  // Optional
  string ledger_id = 1;
}

message GetLedgerEndResponse {
  // The absolute offset of the current ledger end.
  string offset = 1;
}
