// Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
// SPDX-License-Identifier: Apache-2.0

package com.digitalasset.canton.domain.sequencing

import cats.data.EitherT
import cats.syntax.traverseFilter._
import com.digitalasset.canton.DomainId
import com.digitalasset.canton.crypto.{Crypto, KeyName, SigningPublicKey, SigningPublicKeyWithName}
import com.digitalasset.canton.domain.sequencing.admin.protocol.{InitRequest, InitResponse}
import com.digitalasset.canton.tracing.Traced

import scala.concurrent.{ExecutionContext, Future}

object SequencerKeyInitialization {

  // prefix given to keys generated by the sequencer initializer. should follow with the domain id serialized to a string.
  private val sequencerInitialKeyPrefix = "sequencer-initial-"

  /** Will create a sequencer key for the requested domain on the first call.
    * Subsequent calls will just return the key if for the original domain, or fail if different domain id is provided.
    * MUST be called sequentially (this is taken care of by the SequencerInitializationService when used)
    */
  def ensureKeyExists(crypto: Crypto)(
      request: Traced[InitRequest]
  )(implicit executionContext: ExecutionContext): EitherT[Future, String, InitResponse] =
    request.withTraceContext { implicit traceContext => request =>
      // Looks for an existing sequencer key that we've initialized.
      // If it finds one but it doesn't match the domain-id we're attempting to initialize it will return an error instead.
      def findExistingKey(domainId: DomainId): EitherT[Future, String, Option[SigningPublicKey]] = {
        // Find all signing keys with the sequencer initial and for which we have a private key
        val existingKeysEitherT: EitherT[Future, String, List[(String, SigningPublicKey)]] = for {
          keys <- crypto.cryptoPublicStore.publicKeysWithName.leftMap(_.toString)
          keysWithName = keys.collect {
            case SigningPublicKeyWithName(pk: SigningPublicKey, Some(name))
                if name.unwrap.startsWith(sequencerInitialKeyPrefix) =>
              (name.unwrap.stripPrefix(sequencerInitialKeyPrefix), pk)
          }
          existingKeys <- keysWithName.toList
            .filterA { case (_, pk) =>
              crypto.cryptoPrivateStore.existsSigningKey(pk.id)
            }
            .leftMap(_.toString)
        } yield existingKeys

        existingKeysEitherT.subflatMap { existingKeys =>
          val existingKeyForDomain = existingKeys
            .find { case (keyDomainId, _) => domainId.toProtoPrimitive.equals(keyDomainId) }

          existingKeyForDomain.fold[Either[String, Option[SigningPublicKey]]](
            Either.cond(
              existingKeys.isEmpty, // have we initialized for other domains
              None, // no existing sequencer keys generated during initialization
              s"Sequencer has been previously initialized for domains: ${existingKeys.map(_._1).mkString(",")}",
            )
          ) { case (_, key) =>
            Right(Some(key)) // take the existing key
          }
        }
      }

      for {
        keyName <- EitherT.fromEither[Future](
          KeyName.create(s"$sequencerInitialKeyPrefix${request.domainId.toProtoPrimitive}")
        )
        existingKey <- findExistingKey(request.domainId)
        key <- existingKey.fold(
          crypto
            .generateSigningKey(name = Some(keyName))
            .leftMap(err => s"Failed to generate sequencer signing key: $err")
        )(k => EitherT.rightT(k))
        // todo(i6244): perhaps nt unwrap here
      } yield InitResponse(keyName.unwrap, key, replicated = false)
    }
}
