Database Interaction
====================

This guide explains common pitfalls when interacting with the database.

# SQL casing

We use **lowercase** for SQL keywords, in contrast to the traditional style of writing them in `UPPERCASE`.

The goal is consistency.

So this style

```sql
select id, name from my_tbl where id = $id;
```

instead of that

```sql
SELECT id, name FROM my_tbl WHERE id = $id;
```

# String limitation

We limit the length of string-based identifiers as early as possible on the server side to prevent that string-based
identifiers are silently truncated upon persistence to the databases,
or that we accept an identifier that later turns out to be impossible to handle correctly. For details, please see the
documentation at `LengthLimitedString` for reference.
We also prohibit fixed length strings in DB schemas not to experience silent truncation and/or discrepancies due to
different DB character encodings. (Also in case of postgres there is no performance benefit doing so.)

# Collation

Postgres compares strings using a localized comparison operator specified by the collation.
Almost all our `varchar` fields in DB tables do not store natural language text, but some machine-readable identifier.

* For Postgres, `varchar` column definitions should therefore specify the collation `"C"` such that codepoint ordering
  is used.
  ```sql
  some_identifier varchar collate "C" not null
  ```

* H2 does not use collations by default and therefore does not need any specification.
  H2 does not understand Postgres' `collate "C"` directive though.

# Debug Logging

Add the following lines to `logback-test.xml` to enable logging loads of information:

```xml

<logger name="slick.jdbc.JdbcBackend.statement" level="DEBUG"/>
<logger name="slick.jdbc.JdbcBackend.parameter" level="DEBUG"/>
```

# Database Upserts

Writes to the database maybe retried for a variety of reasons.
Therefore, writes to the database must be idempotent.
However, doing so in a manner supported by H2 and Postgres can be tricky given the frequently similar but not entirely
identical syntax.
Here we present the most common approaches depending on the action you would like to take upon finding conflicts.

## Insert and `on conflict do nothing`

H2 has support for `insert ... on conflict do nothing` which matches the Postgres syntax, so the same statement
can be used for both databases (for actions other than doing nothing in H2 you will have to resort to a `merge`
statement).

```sql
insert into tbl (id, value) values ($id, $value) on conflict do nothing
```

## Insert and Check Existing on Conflict

For append-only stores where there is no modification or removal of existing data the above pattern (
`insert and do nothing`)
is technically sufficient, however it is sometimes preferable to check that the existing data that prevented rows from
being
inserted matches the data we were trying to insert.

The pattern we use is to perform the insert as above but then query the existing data if the number of rows the
database reported that it inserted is less than the expected number we attempted to write.
The helper method `IdempotentInsert.insertVerifyingConflicts` performs this insert check and potentially select process.
See scaladoc on `insertVerifyingConflicts` for further details on usage.

## Insert New or Update Existing

When you intend to update an existing row if it is present, Postgres supports a `insert .. on conflict do update`,
where as H2 needs to use a `merge into` statement.

Postgres example:

```sql
insert into my_tbl (id, name)
  values ($id, $name)
  on conflict (id) do
    update set name = $name
```

H2 example:

```sql
merge into my_tbl using dual
  on (id = $id)
  when matched then
    update set name = $name
  when not matched then
    insert (id, name) values ($id, $name)
```

Remark: if several `merge` statements are executed concurrently, H2 may result in a spurious constraint violation error,
because the decision to insert is made based on a stale version of the table.
To work around this, Canton will retry a statement for a limited number of times, if it fails with a constraint
violation error.

# Identity Columns vs. Serial

For columns that require an auto-generated, sequential number, use `identity` columns instead of the older,
postgres-specific `serial` type.
The recommended syntax is `generated always as identity`, as it is stricter and prevents the application from manually
inserting an id, which avoids bugs.
Use the alternative, **`generated by default as identity`**, only when you explicitly need to override the
database-generated value, such as during data migrations.

Using `identity` is better because it is:

* **The SQL Standard**: More portable and its purpose is explicit.
* **Safer**: `generated always` protects the integrity of the auto-generated sequence.
* **Consistent**: Works on both Postgres and H2.
* **Not nullable**: No need to add `not null`.

## `identity` and `primary key`s

Note that `identity` (auto-generation) and `primary key` (uniqueness) are separate constraints. They are often used
together on the same column, but they do not have to be.

**Common Case (`identity` as the `primary key`):**

```sql
create table my_tbl (
  id bigint generated always as identity primary key,
  name varchar not null,
);
